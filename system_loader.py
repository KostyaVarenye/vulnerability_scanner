import json


class SystemLoader:
    """SystemLoader prepares the input for vulnerability search by loading vms, fw-rules,
    filters the vm tags and rules to have only the relevant information.
    :param: input_file - path to the json input file"""

    def __init__(self, input_file='./data/input.json'):
        self.input_file = input_file
        self.data = None
        self.known_tags = None
        self.vmid_to_tags = None
        self.filtered_rules = None
        self.load_data()

    def load_data(self):
        """load json from file"""
        # if self.input_file:
        #     with open(self.input_file, 'r') as file:
        #         self.data = json.loads(file.read())
        # else:
        #     # default with './data/input.json'
        #     with open('/data/input.json', 'r') as file:
        #         self.data = json.loads(file.read())
        try:
            with open(self.input_file, 'r') as file:
                data = file.read()
                self.data = json.loads(data)
        except FileNotFoundError:
            with open('./data/input.json', 'r') as file:
                data = file.read()
                self.data = json.loads(data)
        # calling this function will force all method to lazy load now
        # it is not necessary but, I left it here for now for debugging
        # since bugs are shown faster like that
        # self.filter_prep()

    def get_vms(self):
        """returns vms dict object"""
        return self.data["vms"]

    def get_fw_rules(self):
        """returns fw_rules dict object"""
        return self.data["fw_rules"]

    def get_known_tags(self):
        """
        :returns a set (without repetitions) of all possible vm tags
        """
        if self.known_tags is not None:
            return self.known_tags

        # load data
        new_set = set()
        for vm in self.get_vms():
            # if we have an empy tag, do not include vm
            if vm['tags']:
                new_set = new_set.union(set(vm['tags']))
        self.known_tags = new_set
        return self.known_tags

    def get_filetered_rules(self):
        """:returns filtered rules, those which have their source/destination in current online vms"""
        if self.filtered_rules is not None:
            return self.filtered_rules

        self.filter_prep()
        return self.filtered_rules

    def get_vmid_to_tags(self):
        """
        create a dictionary {vm_id -> [tags]}
        :returns: dict
        """
        if self.vmid_to_tags is not None:
            return self.vmid_to_tags

        # load data
        d = dict()
        for vm in self.get_vms():
            d[vm['vm_id']] = vm['tags']
        self.vmid_to_tags = d
        return self.vmid_to_tags

    def filter_prep(self):
        """Filter prepping firewall rules only to those we have both source and destination in vm tags,
        ignored rules: having one of source or destination missing. dict will be {"dest": -> {"source/s"}}
        :returns dict['str'] = {set()}"""
        if self.filtered_rules is not None:
            return self.filtered_rules

        # load data

        # filtered (flipped) rules from destination node to source
        filtered_rules = {}
        for fw in self.get_fw_rules():
            # check if we can eliminate rules which are not in source or dest of all vm tags
            if fw['source_tag'] not in self.get_known_tags() or \
                    fw['dest_tag'] not in self.get_known_tags():
                pass  # do nothing if they are irrelevant
            else:
                # do something only if the rules are in current vm in the system
                # here we build the set of our relevant rules str -> set
                # if there is destination rule in the filter already,
                # Lastly, we Unionize the rules together with our new ones
                if filtered_rules.get(fw['dest_tag']):
                    filtered_rules[fw['dest_tag']] = filtered_rules[fw['dest_tag']].union([fw['source_tag']])
                else:
                    # check is redundant, we are guaranteed to get a list here.
                    filtered_rules[fw['dest_tag']] = {fw['source_tag']}

        self.filtered_rules = filtered_rules
        return self.filtered_rules
