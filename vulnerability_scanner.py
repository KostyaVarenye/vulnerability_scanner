class VulnerabilityScanner:
    """VulnerabilityScanner """
    def __init__(self, vm_id, vmid_dict, filtered_rules):
        self.vm_id = vm_id
        self.target_tags = None
        self.vmid_dict = vmid_dict
        self.set_of_penetrating_tags = None
        self.filtered_rules = filtered_rules

    # get the tags of the SEARCHED VULNERABLE vm_id(attack route)
    def get_target_tags(self):
        """get target list of tags"""
        if self.target_tags is not None:
            return self.target_tags

        try:
            t = self.vmid_dict[self.vm_id]
        except KeyError:
            t = []
        self.target_tags = t
        return self.target_tags

    # identify tags, take the list of tags, turn them into set
    def get_a_set_of_penetrating_tags(self):
        """get the vulnerable tags from the filtered rules dictionary, as a set"""
        if self.set_of_penetrating_tags is not None:
            return self.set_of_penetrating_tags

        s = set()
        for tag in self.get_target_tags():
            if tag in self.filtered_rules.keys():
                tmp = self.filtered_rules.get(tag)
                s = s.union(tmp)
        self.set_of_penetrating_tags = s
        return self.set_of_penetrating_tags

    def find_potential_attackers(self):
        """method requires set of tags that can attack and a dictionary of rules vm_id->tags.
        It and returns a list of vm's which have the tags that can potentially attack"""
        answer = []
        # used as to not check already seen vm id's, append self vmid, this way vm attack itself is ignored.
        seen = {self.vm_id:True}
        for tag in self.get_a_set_of_penetrating_tags():
            if len(seen.items()) != len(self.vmid_dict.items()):
                for vm_id in self.vmid_dict.keys():
                    if tag in self.vmid_dict[vm_id] and not seen.get(vm_id):
                        answer.append(vm_id)
                        seen[vm_id] = True
            else: break
        return answer
